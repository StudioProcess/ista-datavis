<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ISTA Datavis Sketch</title>
    <script src="./node_modules/p5/lib/p5.js"></script>
    <link rel="stylesheet" href="./style.css">
</head>
<body>
    <script type="module">
    
        // KEYS
        // Left, Right ... Prev page / next page
        // S ... Save page (PNG)
    
        // --------------------------------------------------------------------------------
       
        const DATA_SORTING = 'location'; // id, time, location, color
        const SNP_SORTING = 0; // [ 'default', 'color_start', 'color_middle', 'color_end', 'alpha' ];
        
        const SNP_COUNT = 100; // How many SNPs to show
       
        // Number of samples horizontally
        const X_COUNT = 30;
        
        // Number of samples vertically
        const Y_COUNT = 50;
        
        // Size of each sample tile (together with X_COUNT/Y_COUNT determines canvas size)
        // Smaller (ca. 30) for quick rendering, higher (ca. 100) for high-res save
        const TILE_SIZE = 50;
        
        // Show the grid of samples?
        const SHOW_GRID = true;
        
        // Show the ID text?
        const SHOW_ID = false;
        
        // Show the center circle (yellow/red marker)?
        const SHOW_SPOT = false;
        
        // Show the bottom "timeline" markings
        const SHOW_TIMELINE = true;
        
        // Show border around each sample tile?
        const SHOW_BORDER = true;
        
        // Adjust size of center circle
        const SPOT_SCALE = 6.0;
        
        // Adjust size of bottom "timeline" markings
        const TIMELINE_SCALE = 3.0;
        
        // Colors for SNP values 0/1/2
        const COL = {
            0: [255, 240, 30],
            1: [255, 255, 221],
            2: [255, 55, 140]
        };
        
        // Color for SNP no data
        const COL_NODATA = [40];
        
        // Color for Red value
        const COL_R = [255, 55, 140];
        
        // Color for Yellow value
        const COL_Y = [255, 255, 0];
        
        // Color for ID Label
        const COL_ID = [40];
        
        // Color for Timeline markings
        const COL_TIMELINE = [128];
        
        // Color for border around each "QR Code"
        const BORDER_COL = [0, 60];
        
        // Border thickness
        const BORDER_SCALE = 0.1;
        
        // --------------------------------------------------------------------------------
        
        import data from './data.mjs'
        import util from './util.mjs';
        
        let sample_offset = 0;
        let start_idx, end_idx;
        const sketch_ts = util.timestamp();
        
        let snp_count = SNP_COUNT;
        let snp_sorting = SNP_SORTING;
        
        let grid = util.rectangle(snp_count);
        console.log('grid', grid);
        
        let font;
        
        async function preload() {
            util.begin_preload();
            await data.load('./data/dataMartin.csv');
            console.log(data.raw());
            
            font = await util.load_font('./fonts/soehne-mono-leicht.ttf');
            util.end_preload();
        }
    
        async function setup() {
            data.sort(DATA_SORTING);
            data.sort_snps(snp_sorting, snp_count);
            
            noLoop();
            pixelDensity(1);
            createCanvas(X_COUNT * TILE_SIZE, Y_COUNT * TILE_SIZE);
            textFont(font);
        }
        
        // Draw single sample
        function draw_sample(idx) {
            // console.log("SAMPLE #" + idx);
            let s = data.get_sample(idx);
            // console.log(s);
            
            const cell_w = width / grid[0];
            const cell_h = cell_w * (grid[0] / grid[1]);
            const base = width / 10;
            
            // blendMode(BLEND);
            if (SHOW_GRID) {
                noStroke();
                rectMode(CORNER);
                for ( let [idx, val] of Object.values(s.snps).entries() ) {
                const x = (idx % grid[0]) * cell_w;  
                const y = Math.floor(idx / grid[0]) * cell_h;
                    if ( val < 0) {
                        fill( ...COL_NODATA );
                    } else {
                        fill( ...COL[val] );
                    }
                    rect(x, y, cell_w, cell_h);
                }
            }
            
            // spot with flower color
            if (SHOW_SPOT) {
                const spot_w = base * 2 * 2/3 * SPOT_SCALE;
                const spot_h = spot_w;
                fill(255);
                noStroke();
                rectMode(CORNER);
                // stroke(0);
                // strokeWeight(1);
                ellipse(width/2, width/2, spot_w, spot_h);
                noStroke();
                
                // arc left (red)
                if (s.color.red < 0) {
                    fill(0);
                } else {
                    let alpha = map(s.color.red, 0, 5, 0, 255);
                    fill(...COL_R, alpha);
                }
                arc(width/2, width/2, spot_w, spot_h, HALF_PI, HALF_PI+PI);
                
                // arc right (yellow)
                if (s.color.yellow < 0) {
                    fill(0);
                } else {
                    let alpha = map(s.color.yellow, 0, 5, 0, 255);
                    fill(...COL_Y, alpha);
                }
                arc(width/2, width/2, spot_w, spot_h, HALF_PI+PI, HALF_PI+TWO_PI);
            }
            
            // timeline
            if (SHOW_TIMELINE) {
                noStroke();
                fill(...COL_TIMELINE);
                // blendMode(BLEND);
                rectMode(CENTER);
                const marker_w = base * 0.33 * TIMELINE_SCALE;
                const marker_h = marker_w;
                for (let year of s.years) {
                    let x = map(year, 2009, 2019, 0, width);
                    rect(x, width - marker_h / 2, marker_w, marker_h);
                }
                // connector from first to last year
                if (s.year_first != s.year_last) {
                    let x_start = map(s.year_first, 2009, 2019, 0, width);
                    let x_end   = map(s.year_last, 2009, 2019, 0, width);
                    rectMode(CORNER);
                    rect(x_start + marker_w/2, width - marker_h/3, x_end - x_start - marker_w, marker_h/3);
                }
            }
            
            // draw id
            if (SHOW_ID) {
                // blendMode(BLEND);
                textAlign(CENTER, CENTER);
                textSize(cell_h * 2);
                fill(...COL_ID);
                stroke(0);
                strokeWeight(2);
                for (let [idx, ch] of s.id.split('').entries() ) {
                    let x = cell_w + idx * (cell_w * 2);
                    text(ch, x, width - cell_h/2);
                }
            }
            
            if (SHOW_BORDER) {
                blendMode(BLEND);
                rectMode(CORNER);
                stroke(...BORDER_COL);
                noFill();
                const border_weight = cell_w * BORDER_SCALE;
                strokeWeight(border_weight);
                rect(0+border_weight, 0+border_weight, cell_w * 10 - border_weight, cell_h * 10 - border_weight);
                rect(0, 0, cell_w * 10, cell_h * 10);
            }
        }
        
        // Automatically scale so x_count fits width
        function draw_mosaic(x_count, y_count, offset=0) {
            start_idx = offset;
            end_idx = Math.min(offset + x_count * y_count - 1, data.num_samples() - 1);
            
            console.log(`SAMPLES #${start_idx}â€“#${end_idx}`);
            const s = 1 / x_count;
            
            scale(s, s);
            
            let i = 0;
            for (let idx=start_idx; idx<=end_idx; idx++) {
                let x = i % x_count * width;
                let y = Math.floor(i / x_count) * width;
                push();
                translate(x, y);
                draw_sample(idx);
                pop();
                i++;
            }
        }
        
        async function draw() {
            background(0);
            draw_mosaic(X_COUNT, Y_COUNT, sample_offset);
        }
        
        function saveFrame(ts = undefined) {
            if (ts == undefined) ts = util.timestamp();
            saveCanvas(`${ts}_${start_idx.toString().padStart(5, '0')}-${end_idx.toString().padStart(5, '0')}.png`);
        }
        
        function scroll_mosaic(offset = 1) {
            sample_offset += offset;
            
            if (sample_offset >= data.num_samples()) {
                sample_offset = 0;
            } else if (sample_offset < 0) {
                sample_offset = data.num_samples() - (data.num_samples() % offset);
                if (offset == -1) sample_idx -= 1;
            }
            
            redraw();
        }
        
        function set_snp_sorting(by, limit) {
            if (by == null || by == undefined) by = snp_sorting;
            if (limit == null || limit == undefined) limit = snp_count;
            if (limit != snp_count) {
                grid = util.rectangle(limit);
                console.log('grid', grid);
            }
            snp_sorting = by;
            snp_count = limit;
            data.sort_snps(snp_sorting, snp_count);
            redraw();
        }
        
        function keyPressed(e) {
            if (e.key == 'ArrowLeft') {
                scroll_mosaic(-X_COUNT * Y_COUNT);
            } else if (e.key == 'ArrowRight') {
                scroll_mosaic(X_COUNT * Y_COUNT);
            } else if (e.key == 's') {
                saveFrame(sketch_ts);
            } else if (e.key >= '1' && e.key <= '5') {
                set_snp_sorting (parseInt(e.key), null );
            } else if ( (e.key >= '6' && e.key <= '9') || e.key == '0' ) {
                let idx = parseInt(e.key);
                if (idx == 0) idx = 4;
                else idx -= 6;
                const options = [ 6, 12, 25, 50, 100 ];
                set_snp_sorting( null, options[idx] );
            }
        }
        
        util.register_global(preload, setup, draw, keyPressed);
        
    </script>
</body>
</html>