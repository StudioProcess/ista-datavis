<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ISTA Datavis Sketch</title>
    <script src="./node_modules/p5/lib/p5.js"></script>
    <link rel="stylesheet" href="./style.css">
</head>
<body>
    <script type="module">
    
        // KEYS
        
        // SPACE ... Toggle mesh
        
        // RMB Drag ... Pan
        // Wheel ... Zoom
        // 0 ... Reset Zoom
        // +/-  ... Zoom In/Out
        // WASD ... Pan Up/Left/Down/Right
        
        // Left, Right ... Prev page / next page
        // 1-9 ... Dithering strength
        // X ... Save image (PNG)
        
        // --------------------------------------------------------------------------------
    
        const DATA_SORTING = 'location'; // id, time, location, color
    
        const COUNT_X = 41;
        const COUNT_Y = 73;
        
        // Color for Red value
        const COL_R = [255, 0, 0];
        
        // Color for Yellow value
        const COL_Y = [255, 255, 0];
        
        const FRAMERATE = 30;
        
        // --------------------------------------------------------------------------------
        
        import data from './data.mjs'
        import util from './util.mjs';
        
        let sample_offset = 0;
        let start_idx, end_idx;
        const sketch_ts = util.timestamp();
        let zoom = 1;
        let shift_x = 0;
        let shift_y = 0;
        const count = COUNT_X * COUNT_Y;
        let my_shader;
        let noise_texture;
        let dither_bias = -0.2;
        let dither_steps = 4;
        let dither_strength = 0.25;
        let show_mesh = false;
        
        async function preload() {
            util.begin_preload();
            my_shader = loadShader('./shaders/dither.vert.glsl', './shaders/dither.frag.glsl');
            noise_texture = loadImage('./images/1024_LDR_RGBA_0.png');
            
            await data.load('./data/dataMartin.csv');
            console.log(data.raw());
            util.end_preload();
        }
        
        const COLOR_0 = '#ffd0d4';
        const COLOR_1 = '#ff2ac2';
        const COLOR_2 = '#ffffff';
        
        const CELL_INNER_DIAMETER = 0.85;
        
        let geo;
        
        function buildMeshCell(x, y, c0, c1, c2, side=500, inner_diameter = 0.85) {
            const radius = side * inner_diameter / 2;
            
            // Center to Mid
            beginShape(TRIANGLE_FAN);
            fill(c0);
            vertex(x, y, 0);
            fill(c1);
            vertex(x + radius, y, 0);
            
            for (let rot = 45; rot <= 360; rot += 45) {
                const rot_rad = radians(rot);
                vertex( x + radius * cos(rot_rad), y + radius * sin(rot_rad), 0 );
            }
            endShape();
            
            // Outer Bottom Right
            beginShape(TRIANGLE_FAN);
            fill(c2);
            vertex(x + side/2, y + side/2, 0);
            vertex(x + side/2, y - side/2, 0);
            fill(c1);
            for (let rot = 0; rot <= 90; rot += 45) {
                const rot_rad = radians(rot);
                vertex( x + radius * cos(rot_rad), y + radius * sin(rot_rad), 0 );
            }
            endShape();
            
            // Outer Bottom Left
            beginShape(TRIANGLE_FAN);
            fill(c2);
            vertex(x - side/2, y + side/2, 0);
            vertex(x + side/2, y + side/2, 0);
            fill(c1);
            for (let rot = 90; rot <= 180; rot += 45) {
                const rot_rad = radians(rot);
                vertex( x + radius * cos(rot_rad), y + radius * sin(rot_rad), 0 );
            }
            endShape();
            
            // Outer Top Left
            beginShape(TRIANGLE_FAN);
            fill(c2);
            vertex(x - side/2, y - side/2, 0);
            vertex(x - side/2, y + side/2, 0);
            fill(c1);
            for (let rot = 180; rot <= 270; rot += 45) {
                const rot_rad = radians(rot);
                vertex( x + radius * cos(rot_rad), y + radius * sin(rot_rad), 0 );
            }
            endShape();
            
            // Outer Top Right
            beginShape(TRIANGLE_FAN);
            fill(c2);
            vertex(x + side/2, y - side/2, 0);
            vertex(x - side/2, y - side/2, 0);
            fill(c1);
            for (let rot = 270; rot <= 360; rot += 45) {
                const rot_rad = radians(rot);
                vertex( x + radius * cos(rot_rad), y + radius * sin(rot_rad), 0 );
            }
            endShape();
        }
        
        
        function buildMesh() {
            const side = width / COUNT_X;
            
            beginGeometry();
            
            start_idx = sample_offset;
            end_idx = Math.min(sample_offset + count - 1, data.num_samples() - 1);
            console.log(`SAMPLES #${start_idx}â€“#${end_idx}`)
            
            for (let i=0; i<count; i++) {
                if (sample_offset + i > end_idx) {
                    break;
                }
                const s = data.get_sample(sample_offset + i);
                let c0;
                if (s.color.yellow < 0) {
                    c0 = [0,0,0];
                } else {
                    c0 = lerpColor( color(255,255,255), color(COL_Y), map(s.color.yellow, 0, 5, 0, 1) );
                }
                let c1;
                if (s.color.red < 0) {
                    c1 = [0,0,0];
                } else {
                    c1 = lerpColor( color(255,255,255), color(COL_R), map(s.color.red, 0, 5, 0, 1) );
                }
                const c2 = [255, 255, 255];
                const x = -width/2  + side/2 + i % COUNT_X * side;
                const y = -height/2 + side/2 + floor(i / COUNT_X) * side;
                buildMeshCell(x, y, c0, c1, c2, side, CELL_INNER_DIAMETER);
            }

            return endGeometry();
        }
        
        function rebuildMesh() {
            if (geo != undefined) {
                freeGeometry(geo);
                geo = undefined;
            }
            geo = buildMesh();
            console.log(geo);
        }
        
        async function setup() {
            data.sort(DATA_SORTING);
            
            createCanvas(2160, 3840, WEBGL);

            pixelDensity(1);
            ortho();
            strokeWeight(0.5);
            
            // textureWrap(REPEAT, REPEAT);
            frameRate(FRAMERATE);
            
            // geo = buildMeshCell(-500, 0, COLOR_0, COLOR_1, COLOR_2);
            
            rebuildMesh();
        }
        
        async function draw() {
            background(255);
            
            orbitControl(0, 0, 1);
            
            scale(zoom);
            translate(shift_x * width/100, shift_y * width/100);
            
            shader(my_shader);
            my_shader.setUniform('uNoiseTexture', noise_texture);
            my_shader.setUniform('uDitherBias', dither_bias);
            my_shader.setUniform('uDitherStrength', dither_strength);
            my_shader.setUniform('uDitherSteps', dither_steps);
            my_shader.setUniform('uRandomness', [random(), random(), random(), random(),]);
            my_shader.setUniform('uTime', millis() / 1000);
            my_shader.setUniform('uFrame', frameCount)
            
            if (show_mesh) {
                stroke(50);
            } else {
                noStroke();
            }
            model(geo);
        }
        
        function saveFrame(ts = undefined) {
            if (ts == undefined) ts = util.timestamp();
            saveCanvas(`${ts}_${start_idx.toString().padStart(5, '0')}-${end_idx.toString().padStart(5, '0')}.png`);
        }
        
        function page(offset = 1) {
            sample_offset += offset;
            
            if (sample_offset >= data.num_samples()) {
                sample_offset = 0;
            } else if (sample_offset < 0) {
                sample_offset = data.num_samples() - (data.num_samples() % offset);
                if (offset == -1) sample_offset -= 1;
            }
            
            rebuildMesh();
        }
        

        function keyPressed(e) {
            if (key == '+' || key == '=') {
                zoom *= 2;
            } else if (key == '0') {
                zoom = 1;
            } else if (key == '-') {
                zoom = max(zoom / 2 , 1);
            } else if (key == 'w') {
                shift_y += 1;
            } else if (key == 'a') {
                shift_x += 1;
            } else if (key == 's') {
                shift_y -= 1;
            } else if (key == 'd') {
                shift_x -= 1;
            } else if (e.key == 'ArrowLeft') {
                page(-count);
            } else if (e.key == 'ArrowRight') {
                page(count);
            } else if (e.key == 'x') {
                saveFrame(sketch_ts);
            } else if (e.key >= '1' && e.key <= '9') {
                dither_strength = map(e.keyCode - 48, 1, 9, 0, 1);
                console.log(`Dithering Strength: ${dither_strength}`);
            } else if (e.key == ' ') {
                show_mesh = !show_mesh;
            }
        }
        
        util.register_global(preload, setup, draw, keyPressed);
        
    </script>
</body>
</html>