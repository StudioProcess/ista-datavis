<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ISTA Datavis Sketch</title>
    <script src="./node_modules/p5/lib/p5.js"></script>
    <link rel="stylesheet" href="./style.css">
</head>
<body>
    <script type="module">
        
        // KEYS
        // Left, Right ... Prev sample / Next sample
        // S ... Save Sample (PNG)
        // X ... Save all samples consecutively
        
        // --------------------------------------------------------------------------------
        
        const DATA_SORTING = 'location'; // id, time, location, color
        const SNP_SORTING = 0; // [ 'default', 'color_start', 'color_middle', 'color_end', 'alpha' ];
        
        const SNP_COUNT = 100; // How many SNPs to show
        
        // Colors for SNP values 0/1/2
        const COL = {
            0: [255, 240, 30],
            //1: [255, 148, 85], // midpoint 
            1: [255, 255, 221],
            2: [255, 55, 140]
        };
        
        // Color for SNP no data
        const COL_NODATA = [40];
            
        // Color for Red value
        const COL_R = [255, 55, 140];
        
        // Color for Yellow value
        const COL_Y = [255, 255, 0];
        
        // Color for ID Label
        const COL_ID = [40];
        
        // Color for Timeline markings
        const COL_TIMELINE = [0];
        
        // Start / end index when using "Save all" (-1 means last)
        const SAVE_ALL = [0, 1999];
        
        const MARK_COLOR_SNPS = true;
        const MARK_COL = [128, 128, 100];
        const MARK_SCALE = 0.15;
        const MARK_STYLE = 1; // 0 .. Centered circle, 1 .. B/L square
        
        const SPOT_STYLE = 1; // 0 .. Half circles, 1 .. Concentric circles
    
        // --------------------------------------------------------------------------------
        
        import data from './data.mjs'
        import util from './util.mjs';
        
        let sample_idx = 0; // current sample index
        let snp_sorting = SNP_SORTING;
        let snp_count = SNP_COUNT;
        
        let grid = util.rectangle(snp_count);
        console.log('grid', grid);
    
        async function preload() {
            await util.preload( data.load('./data/dataMartin.csv') );
            // console.log(data.raw().columns);
        }
    
        async function setup() {
            data.sort(DATA_SORTING);
            data.sort_snps(SNP_SORTING, snp_count);
            
            noLoop();
            pixelDensity(1);
            createCanvas(2000, 2000); // this actually starts the draw loop
        }
        
        // Draw single sample
        function draw_sample(idx) {
            console.log("SAMPLE #" + sample_idx);
            
            let s = data.get_sample(idx);
            console.log(s);
            
            const cell_w = width / grid[0];
            const cell_h = height / grid[1];
            const base = width / 10;
            
            blendMode(BLEND);
            noStroke();
            rectMode(CORNER);
            for ( let [idx, val] of Object.values(s.snps).slice(0, snp_count).entries() ) {
                noStroke();
                rectMode(CORNER);
                const x = (idx % grid[0]) * cell_w;  
                const y = Math.floor(idx / grid[0]) * cell_h;
                if ( val < 0) {
                    fill( ...COL_NODATA );
                } else {
                    fill( ...COL[val] );
                }
                rect(x, y, cell_w, cell_h);
                
                let mark_size = cell_w * MARK_SCALE;
                if (MARK_COLOR_SNPS && data.color_snp_indices().includes(idx)) {
                    fill(...MARK_COL);
                    if (MARK_STYLE == 1) {
                        rectMode(CORNERS);
                        rect( x + cell_w - mark_size, y + cell_h - mark_size, x + cell_w, y + cell_h );
                    } else {
                        circle(x + cell_w/2, y + cell_h/2, mark_size);
                    }
                }
            }
            
            // spot with flower color
            const spot_w = base * 2 * 2/3;
            const spot_h = spot_w;
            
            
            fill(255);
            // stroke(0);
            // strokeWeight(1);
            noStroke();
            ellipse(width/2, height/2, spot_w, spot_h);
            const col_red = s.color.red < 0 ? [0] : [ ...COL_R, map(s.color.red, 0, 5, 0, 255) ];
            const col_yellow = s.color.yellow < 0 ? [0] : [ ...COL_Y, map(s.color.yellow, 0, 5, 0, 255) ];

            if (SPOT_STYLE == 1) {
                let outer_color;
                let inner_color;
                if (s.color.red >= s.color.yellow) {
                    outer_color = col_red;
                    inner_color = col_yellow;
                } else {
                    outer_color = col_yellow;
                    inner_color = col_red;
                }
                // outer
                fill(...outer_color);
                ellipse(width/2, height/2, spot_w, spot_h);
                // inner
                fill(255);
                ellipse(width/2, height/2, spot_w/2, spot_h/2);
                fill(...inner_color);
                ellipse(width/2, height/2, spot_w/2, spot_h/2);
           } else {
                // arc left (red)
                fill(col_red);
                arc(width/2, height/2, spot_w, spot_h, HALF_PI, HALF_PI+PI);
                
                // arc right (yellow)
                fill(col_yellow);
                arc(width/2, height/2, spot_w, spot_h, HALF_PI+PI, HALF_PI+TWO_PI);
            }
            
            // timeline
            fill(...COL_TIMELINE);
            blendMode(BLEND);
            rectMode(CENTER);
            const marker_w = base * 0.33;
            const marker_h = marker_w;
            for (let year of s.years) {
                let x = map(year, 2009, 2019, 0, width);
                rect(x, height - marker_h / 2, marker_w, marker_h);
            }
            // connector from first to last year
            if (s.year_first != s.year_last) {
                let x_start = map(s.year_first, 2009, 2019, 0, width);
                let x_end   = map(s.year_last, 2009, 2019, 0, width);
                rectMode(CORNER);
                rect(x_start + marker_w/2, height - marker_h/3, x_end - x_start - marker_w, marker_h/3);
            }
            
            // draw id
            blendMode(BLEND);
            textAlign(CENTER, CENTER);
            textSize(base * 2/3);
            fill(...COL_ID);
            stroke(255);
            strokeWeight(base * 0.001);
            for (let [idx, ch] of s.id.split('').entries() ) {
                let x = base + idx * (base * 2);
                text(ch, x, height - base/2);
            }
        }
        
        async function draw() {
            background(255);
            
            // const stats = data.get_stats();
            // console.log(stats);
            // console.log( JSON.stringify(stats, null, 2) )
            
            draw_sample(sample_idx);
        }
        
        function next_sample(offset = 1) {
            sample_idx += offset;
            
            if (sample_idx >= data.num_samples()) {
                sample_idx = 0;
            } else if (sample_idx < 0) {
                sample_idx = data.num_samples() - (data.num_samples() % offset);
                if (offset == -1) sample_idx -= 1;
            }
            
            redraw();
        }
        
        function saveSample(idx = sample_idx, ts = undefined) {
            sample_idx = idx;
            redraw();
            if (ts == undefined) ts = util.timestamp();
            saveCanvas(`${ts}_${idx.toString().padStart(5, '0')}.png`);
        }
        
        function record(start=0, end=-1) {
            const SAVE_INTERVAL = 100;
            
            while (start < 0) {
                start += data.num_samples();
            }
            while (end < 0) {
                end += data.num_samples();
            }
            console.log(`RECORDING #${start}â€“#${end}`);
            
            const ts = util.timestamp();
            
            let idx = start;
            function saveloop() {
                saveSample(idx, ts);
                idx += 1;
                if (idx <= end) {
                    setTimeout(saveloop, SAVE_INTERVAL)
                }
            }
            saveloop();
        }
        
        function set_snp_sorting(by, limit) {
            if (by == null || by == undefined) by = snp_sorting;
            if (limit == null || limit == undefined) limit = snp_count;
            if (limit != snp_count) {
                grid = util.rectangle(limit);
                console.log('grid', grid);
            }
            snp_sorting = by;
            snp_count = limit;
            data.sort_snps(snp_sorting, snp_count);
            redraw();
        }
        
        function keyPressed(e) {
            if (e.key == 'ArrowLeft') {
                next_sample(-1);
            } else if (e.key == 'ArrowRight') {
                next_sample(1);
            } else if (e.key == 's') {
                saveSample();
            } else if (e.key == 'x') {
                record(...SAVE_ALL);
            } else if (e.key >= '1' && e.key <= '5') {
                set_snp_sorting( parseInt(e.key) - 1, null );
            } else if ( (e.key >= '6' && e.key <= '9') || e.key == '0' ) {
                let idx = parseInt(e.key);
                if (idx == 0) idx = 4;
                else idx -= 6;
                const options = [ 6, 12, 25, 50, 100 ];
                set_snp_sorting( null, options[idx] );
            }
        }
        
        util.register_global(preload, setup, draw, keyPressed);
        
    </script>
</body>
</html>