<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ISTA Datavis Sketch</title>
    <script src="./node_modules/p5/lib/p5.js"></script>
    <link rel="stylesheet" href="./style.css">
</head>
<body>
    <script type="module">
    
        // KEYS
        
        // Left, Right ... Cycle through COLOR-RELEVANT SNPs
        // Up, Down ... Cycle through all SNPs
        // R ... Pick random SNP
        
        // SPACE ... Cycle view (Map, SNP display)
        // S ... Save image (PNG)
        
        // --------------------------------------------------------------------------------
        
        const WIDTH = 2160;
        const HEIGHT = 3840;
        
        // Map border in meters
        const BORDER = 1000;
        
        const ASPECT = (4691188.68583845 - 4684727.2878592) / (434653.007924495 - 410335.103808801);
        const MAP_OPACITY = 150;
        
        // Color for Red value
        const COL_R = [255, 0, 0];
        
        // Color for Yellow value
        const COL_Y = [255, 255, 0];
        
        const COL = {
            0: [255, 240, 30],
            // 1: [255, 165, 0], // orange
            1: [255, 148, 85], // midpoint
            // 1: [255, 255, 221],
            2: [255, 55, 140]
        };
        
        // replacement colors for SNP_STYLE == 1
        const GRAPH_COL = {
            0: [200, 200, 0],
        };
        const GRAPH_WEIGHT = 0.00066; // percentage of canvas diagonal
        
        const COL_BACKGROUND_BRIGHT = [255, 255, 221];
        const COL_BACKGROUND_DARK = [40, 40, 30];
        
        let SNP_STYLE = 1; // 0 ... graph, 1 ... stacked bars
        const BUCKETS = 250;
        const SNP_OPACITY = 250;
        
        const DISPLAY_BORDER = 0.011;
        const DISPLAY_BORDER_BOTTOM = 0.022;
        
        // --------------------------------------------------------------------------------
        
        import data from './data.mjs'
        import util from './util.mjs';
        import recorder from './libs/recorder.js';
        
        const COLOR_SNPS = ["ros_assembly_543443", "ros_assembly_715001", "s91_122561",  "s316_93292", "s316_257789", "s1187_290152"];

        let snp_names;
        let color_snp_idx = 0; // current snp index (within COLOR_SNPS)
        let snp_idx = 0;
        let stats;
        let map_image;
        let locations_image;
        let show_map = false;
        let show_snps = true;
        let show_samples = false;
        let view_mode = 0;
        let font;
        let border;
        const display_diag = Math.sqrt(WIDTH * WIDTH + HEIGHT * HEIGHT);
        
        async function preload() {
            util.begin_preload();
            map_image = await loadImage('./images/hybrid_zone_map_red.png');
            
            await data.load('./data/dataMartin.csv');
            console.log(data.raw());
            
            font = await util.load_font('./fonts/soehne-mono-leicht.ttf');
            util.end_preload();
        }
        
        async function setup() {
            textFont(font);
            
            snp_names = data.snp_names();
            console.log(snp_names);
            
            noLoop();
            pixelDensity(1);
            createCanvas(WIDTH, HEIGHT);
            locations_image = draw_locations();
            
            next_color_snp(0);
        }
        
        function analyze_snp(name) {
            const out = [];
            for (let i=0; i<BUCKETS; i++) {
                out.push({
                    total: 0,
                    no_data: 0,
                    0: 0,
                    1: 0,
                    2: 0,
                });
            }
            
            // sum all values
            for (let i=0; i<data.num_samples(); i++) {
                const s = data.get_sample(i);
                const bucket_idx = int( map(s.geolocation.easting, 410335.103808801, 434653.007924495, 0, BUCKETS-1) );
                const snp_value = s.snps[name];
                out[bucket_idx]['total'] += 1;
                if (snp_value < 0) {
                    out[bucket_idx]['no_data'] += 1;
                } else {
                    out[bucket_idx][snp_value] += 1;
                }
            }
            
            // verify counts
            const sum = { total: 0, no_data: 0, 0: 0, 1: 0, 2:0 };
            for (let i=0; i<BUCKETS; i++) {
                sum.total += out[i].total;
                sum.no_data += out[i].no_data;
                sum[0] += out[i][0];
                sum[1] += out[i][1];
                sum[2] += out[i][2];
            }
            console.assert(sum.total == data.num_samples(), 'num_samples not verified in SNP %s', name);
            console.assert(sum.total == sum.no_data + sum[0] + sum[1] + sum[2], 'Counts not verified in SNP %s', name);
            
            return out;
        }
        
        function draw_locations() {
            const g = createGraphics(width, height);
            g.noStroke();
            for (let i=0; i<data.num_samples(); i++) {
                const s = data.get_sample(i);
                const x = map(s.geolocation.easting, 410335.103808801 - BORDER, 434653.007924495 + BORDER, 0, width);
                const y = map(s.geolocation.northing, 4684727.2878592 - BORDER, 4691188.68583845 + BORDER, height, 0);
                
                let OPACITY = 10;
                
                if (s.color.red > s.color.yellow) {
                    g.fill(...COL_R, OPACITY);
                } else if (s.color.red < s.color.yellow) {
                    g.fill(...COL_Y, OPACITY);
                } else if (s.color.red < 0) {
                    g.fill(0, OPACITY)
                } else {
                    g.fill(255);
                }
                g.circle(x, y, 30);
            }
            return g;
        }
        
        function draw_snp(name) {
            let buckets = analyze_snp(name);
            let prev_x;
            let prev_val;
            
            border = display_diag * DISPLAY_BORDER;
            const border_bottom = display_diag * DISPLAY_BORDER_BOTTOM;
            const avail_width = width - 2 * border;
            const step = avail_width / buckets.length;
            const bar_height = height - border - border_bottom;
            
            push();
            translate(border, border);
            
            for (let i=0; i<buckets.length; i++) {
                const x = map(i, 0, buckets.length-1, 0, avail_width);
                let val = [ 0, 0, 0 ];
                if ( buckets[i]['total'] > 0) {
                    val = [
                        buckets[i][0] / buckets[i]['total'],
                        buckets[i][1] / buckets[i]['total'],
                        buckets[i][2] / buckets[i]['total'],
                    ];
                } else if (i > 0) {
                    val = prev_val;
                }
                
                if (SNP_STYLE == 1) {
                    noStroke();
                    rectMode(CORNERS);
                    let prev_total = 0;
                    for (let idx=0; idx<3; idx++) {
                        fill(...COL[idx], SNP_OPACITY);
                        // accident: 
                        // rect(x, height - (prev_total + val[idx]) * height, x + step, height - (prev_total) * height);
                        rect(x, bar_height - (prev_total + val[idx]) * bar_height, x + step, bar_height - (prev_total) * bar_height);
                        prev_total += val[idx];
                    }
                } else {
                    if (i > 0) {
                        for (let idx=0; idx<3; idx++) {
                            strokeWeight(display_diag * GRAPH_WEIGHT);
                            if (GRAPH_COL[idx]) {
                                stroke(GRAPH_COL[idx]);
                            } else {
                                stroke(COL[idx]);
                            }
                            line(x, bar_height - val[idx] * bar_height, prev_x, bar_height - prev_val[idx] * bar_height);
                        }
                    }
                }
                prev_x = x;
                prev_val = val;
            }
            pop();
        }
        
        async function draw() {
            let snp_name = snp_names[snp_idx]
            console.log(snp_name);
            
            const is_color_snp = COLOR_SNPS.includes(snp_name);
            
            // global background
            if (is_color_snp) {
                background(...COL_BACKGROUND_BRIGHT);
            } else {
                background(...COL_BACKGROUND_DARK);
            }
            
            draw_snp(snp_name);
            textAlign(CENTER, BOTTOM);
            const text_scale = height / 1920;
            textSize(20 * text_scale);
            noStroke();
            
            let display_name = snp_name.toUpperCase();
            if (is_color_snp) {
                display_name = 'â€¢' + display_name;
                fill(...COL_BACKGROUND_DARK);
            } else {
                fill(...COL_BACKGROUND_BRIGHT);
            }
            text(display_name, width/2, height-10*text_scale);
            
            textAlign(RIGHT, BOTTOM);
            text(`SNP ${snp_idx+1}/${snp_names.length}`, width-20*text_scale, height-10*text_scale);
            
            recorder.update();
        }
        
        function timestamp() {
            return (new Date()).toISOString();
        }
        
        function next_color_snp(offset = 1) {
            color_snp_idx += offset;
            while (color_snp_idx < 0) color_snp_idx += COLOR_SNPS.length;
            color_snp_idx %= COLOR_SNPS.length;
            snp_idx = snp_names.indexOf(COLOR_SNPS[color_snp_idx]);
            redraw();
        }
        
        function next_snp(offset = 1) {
            snp_idx += offset;
            while (snp_idx < 0) snp_idx += snp_names.length;
            snp_idx %= snp_names.length;
            redraw();
        }
        
        function random_snp() {
            snp_idx = int(random(0, snp_names.length));
            redraw();
        }
        
        function saveFrame(ts = undefined) {
            if (ts == undefined) ts = timestamp();
            const snp_name = snp_names[snp_idx];
            saveCanvas(`${ts}_${snp_idx.toString().padStart(5, '0')}_${snp_name}.png`);
        }
        
        function switch_snp_style() {
            SNP_STYLE = (SNP_STYLE + 1) % 2;
            redraw();
        }
        
        function record(what) {
            let indices = [];
            
            if (what == 'color') {
                for (let color_snp of COLOR_SNPS) {
                    const idx = snp_names.indexOf(color_snp);
                    indices.push(idx);
                }
            } else if (what == 'non_color') {
                for (let snp_name of snp_names) {
                    if (!COLOR_SNPS.includes(snp_name)) {
                        const idx = snp_names.indexOf(snp_name);
                        indices.push(idx);
                    }
                }
            } else { // all
                for (let i=0; i<snp_names.length; i++) {
                    indices.push(i);
                }
            }
            
            const frames = snp_names.length;
            let i = 0;
            recorder.start({
                frames: indices.length,
                onStart: () => {
                    snp_idx = indices[i];
                    redraw();
                },
                onUpdate: () => {
                    i++;
                    snp_idx = indices[i];
                    if (snp_idx == undefined) snp_idx = 0;
                    redraw();
                },
            });
        }
        
        function keyPressed(e) {
            if (e.key == 'ArrowLeft') {
                next_color_snp(-1);
            } else if (e.key == 'ArrowRight') {
                next_color_snp(1);
            } else if (e.key == 'ArrowUp') {
                next_snp(-1);
            } else if (e.key == 'ArrowDown') {
                next_snp(1);
            } else if (e.key == 's') {
                saveFrame();
            } else if (e.key == 'r') {
                random_snp();
            } else if (e.key == ' ') {
                switch_snp_style();
            } else if (e.key == 'x') {
                record();
            } else if (e.key == 'c') {
                record('color');
            } else if (e.key == 'v') {
                record('non_color');
            }
        }
        
        util.register_global(preload, setup, draw, keyPressed);
        
    </script>
</body>
</html>